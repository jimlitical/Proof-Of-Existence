I made photoToOwnerMap public cause it needs to be accessed by users later. photoHashLength was set to private cause it's only necessary within the contract's context. It's 64 because thats the size of all SHA256 hashs. The struct I made was for storing both the owner's address and the blocktime. It was the value for every key in the photoToOwnerMap. 

In addPhotoToMap I utilized the fail early and fail design loud by requiring the photo's hash to be a valid length. If it isn't it would throw the revert function and end the execution. I thought it was similar to the circuit breaker design but I realized that the circuit break seems to be more of a permanent until another update changes the contract back type of change rather than just this one execution fails type of change. I did the same in my other method getPhotoTimestamp. 

I didn't utilize the state machine design cause I didn't need to have stages for uploading photo hashes to timestamp them. I could see auto deprecation being useful when moving from one hard fork to the next if there were significant issues that my contract could face. I also didn't use the restricting access design pattern because I didn't think the map needed any access restriction and my contract handles cases where people try to upload images that are already in or already belongs to another owner. 
